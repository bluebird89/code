##  类型系统

* 指一个语言的类型体系结构
* Java 语言中，存在两套完全独立的类型系统
    - 一套是值类型系统，主要是基本类型，如 byte、int、boolean、char、double 等，这些类型基于值语义
    - 一套是以 Object 类型为根的对象类型系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建（通过使用关键字 new）。Java 语言中的 Any 类型就是整个对象类型系统的根 —— java.lang.Object 类型，只有对象类型系统中的实例才可以被 Any 类型引用。值类型想要被 Any 类型引用，需要装箱 （boxing）过程，比如 int 类型需要装箱成为 Integer 类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承
* Go 语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型（包括内置类型）增加新方法。而在实现某个接口时，无需从该接口继承（事实上，Go 语言根本就不支持面向对象思想中的继承、实现语法），只需要实现该接口要求的所有方法即可。任何类型都可以被 Any 类型引用。在 Go 语言中，Any 类型就是空接口，即 interface{}
* 侵入式接口:在 PHP 这种单继承语言中，存在着严格的层级关系，一个类只能直接继承自一个父类，一个类也只能实现指定的接口，如果没有显式声明继承自某个父类或者实现某个接口，那么这个类就与该父类或者该接口没有任何关系
    - 实现类必须明确声明自己实现了某个接口。这种实现方式虽然足够明确和简单明了，但也存在一些问题，尤其是在设计标准库的时候，因为标准库必然涉及到接口设计，接口的需求方是业务实现类，只有具体编写业务实现类的时候才知道需要定义哪些方法，而在此之前，标准库的接口就已经设计好了，我们要么按照约定好的接口进行实现，如果没有合适的接口需要自己去设计，这里的问题就是接口的设计和业务的实现是分离的，接口的设计者并不能总是预判到业务方要实现哪些功能，这就造成了设计与实现的脱节
* 一个类只要实现了某个接口要求的所有方法，就说这个类实现了该接口

## 网络编程

* 从服务端来看，代码编写分为以下几个步骤：
    - 建立并绑定 Socket：首先服务端使用 socket() 函数建立网络套接字，然后使用 bind() 函数为套接字绑定指定的 IP 和端口；
    - 监听请求：接下来，服务端使用 listen() 函数监听客户端对绑定 IP 和端口的请求；
    - 接收连接：如果有请求过来，并通过三次握手成功建立连接，则使用 accept() 函数接收并处理该连接；
    - 处理请求与发送响应：服务端通过 read() 函数从上述已建立连接读取客户端发送的请求数据，经过处理后再通过 write() 函数将响应数据发送给客户端。
* 从客户端来看，代码编写分为以下几个步骤：
    - 建立 Socket：客户端同样使用 socket()函数建立网络套接字；
    - 建立连接：然后调用 connect() 函数传入 IP 和端口号建立与指定服务端网络程序的连接；
    - 发送请求与接收响应：连接建立成功后，客户端就可以通过 write() 函数向服务端发送数据，并使用 read() 函数从服务端接收响应。
    
## RPC(Remote Procedure Call，远程过程调用)

* 一种通过网络请求从远程服务器调用服务，而不需要了解底层网络细节的应用程序通信协议
* 基于传输层的 TCP 或 UDP 协议，或者是应用层的 HTTP 协议构建，允许开发者直接调用另一台计算机上的程序，而开发者无需额外地为这个调用过程编写网络通信相关代码，从而使得开发网络分布式应用程序更加容易
* 采用客户端 —— 服务器（C/S）工作模式，请求程序是一个客户端（Client），而远程服务提供程序是一个服务器（Server）
* 当执行一个 RPC 调用时，客户端程序首先会发送一个带有参数的请求到服务端，然后等待服务端响应；在服务端，服务进程保持监听状态，当客户端请求到达时，服务端通过解析请求参数计算出结果，并向客户端发送响应信息，然后继续等待下一个客户端请求。客户端接收到来自服务端的响应信息后，可以执行相应的业务逻辑，也可以继续进行其它 RPC 调用
* net/rpc 包很方便地编写 RPC 服务端和客户端程序，实现了 RPC 协议的相关细节，使得在 Go 语言中实现 RPC 编程非常简单
    - 允许 RPC 客户端程序通过网络或是其他 I/O 连接调用一个服务端对象的公开方法（大小字母开头）
    - 服务端，需要将这个对象注册为可访问的服务，之后该对象的公开方法就能够以远程的方式提供访问
    - 服务端可以注册多个不同类型的对象，但不允许注册同一类型的多个对象。一个对象能被 RPC 服务端设置为可提供远程访问需要满足以下条件： `func (t *T) MethodName(argType T1, replyType *T2) error`
        + 必须是在对象外部可公开调用的方法（首字母大写）；
        + 必须有两个参数，且参数的类型都必须是包外部可以访问的类型或者是 Go 内建支持的类型；
        + 第二个参数必须是一个指针；
        + 方法必须返回一个 error 类型的值
    - 类型 T、T1 和 T2 分别对应服务对象所属类型、请求类型和响应类型，它们默认都会使用 Go 语言内置的 encoding/gob 包进行编码解码

## [GORM 中文文档](https://learnku.com/docs/gorm/2018)

* 结构标签
Column 	指定列的名称
Type 	指定列的类型
Size 	指定列的大小，默认是 255
PRIMARY_KEY 	指定一个列作为主键
UNIQUE 	指定一个唯一的列
DEFAULT 	指定一个列的默认值
PRECISION 	指定列的数据的精度
NOT NULL 	指定列的数据不为空
AUTO_INCREMENT 	指定一个列的数据是否自增
INDEX 	创建带或不带名称的索引，同名创建复合索引
UNIQUE_INDEX 	类似 索引，创建一个唯一的索引
EMBEDDED 	将 struct 设置为 embedded
EMBEDDED_PREFIX 	设置嵌入式结构的前缀名称

* 关联的结构标签
MANY2MANY 	指定连接表名称
FOREIGNKEY 	指定外键
ASSOCIATION_FOREIGNKEY 	指定关联外键
POLYMORPHIC 	指定多态类型
POLYMORPHIC_VALUE 	指定多态的值
JOINTABLE_FOREIGNKEY 	指定连接表的外键
ASSOCIATION_JOINTABLE_FOREIGNKEY 	指定连接表的关联外键
SAVE_ASSOCIATIONS 	是否自动保存关联
ASSOCIATION_AUTOUPDATE 	是否自动更新关联
ASSOCIATION_AUTOCREATE 	是否自动创建关联
ASSOCIATION_SAVE_REFERENCE 	是否引用自动保存的关联
PRELOAD 	是否自动预加载关联

* 所有包含零值的字段，像 0，''，false 或者其他的 零值  不会被保存到数据库中，但会使用这个字段的默认值
* 应该考虑使用指针类型或者其他的值来避免这种情况