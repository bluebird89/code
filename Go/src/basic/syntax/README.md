# 类型系统

指一个语言的类型体系结构

* Java 语言中，存在两套完全独立的类型系统
    - 一套是值类型系统，主要是基本类型，如 byte、int、boolean、char、double 等，这些类型基于值语义
    - 一套是以 Object 类型为根的对象类型系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建（通过使用关键字 new）。Java 语言中的 Any 类型就是整个对象类型系统的根 —— java.lang.Object 类型，只有对象类型系统中的实例才可以被 Any 类型引用。值类型想要被 Any 类型引用，需要装箱 （boxing）过程，比如 int 类型需要装箱成为 Integer 类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承
    
* Go 语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型（包括内置类型）增加新方法。而在实现某个接口时，无需从该接口继承（事实上，Go 语言根本就不支持面向对象思想中的继承、实现语法），只需要实现该接口要求的所有方法即可。任何类型都可以被 Any 类型引用。在 Go 语言中，Any 类型就是空接口，即 interface{}


* 侵入式接口:在 PHP 这种单继承语言中，存在着严格的层级关系，一个类只能直接继承自一个父类，一个类也只能实现指定的接口，如果没有显式声明继承自某个父类或者实现某个接口，那么这个类就与该父类或者该接口没有任何关系
    - 实现类必须明确声明自己实现了某个接口。这种实现方式虽然足够明确和简单明了，但也存在一些问题，尤其是在设计标准库的时候，因为标准库必然涉及到接口设计，接口的需求方是业务实现类，只有具体编写业务实现类的时候才知道需要定义哪些方法，而在此之前，标准库的接口就已经设计好了，我们要么按照约定好的接口进行实现，如果没有合适的接口需要自己去设计，这里的问题就是接口的设计和业务的实现是分离的，接口的设计者并不能总是预判到业务方要实现哪些功能，这就造成了设计与实现的脱节
    
* 一个类只要实现了某个接口要求的所有方法，就说这个类实现了该接口