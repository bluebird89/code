##  类型系统

* 指一个语言的类型体系结构
* Java 语言中，存在两套完全独立的类型系统
    - 一套是值类型系统，主要是基本类型，如 byte、int、boolean、char、double 等，这些类型基于值语义
    - 一套是以 Object 类型为根的对象类型系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建（通过使用关键字 new）。Java 语言中的 Any 类型就是整个对象类型系统的根 —— java.lang.Object 类型，只有对象类型系统中的实例才可以被 Any 类型引用。值类型想要被 Any 类型引用，需要装箱 （boxing）过程，比如 int 类型需要装箱成为 Integer 类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承
* Go 语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型（包括内置类型）增加新方法。而在实现某个接口时，无需从该接口继承（事实上，Go 语言根本就不支持面向对象思想中的继承、实现语法），只需要实现该接口要求的所有方法即可。任何类型都可以被 Any 类型引用。在 Go 语言中，Any 类型就是空接口，即 interface{}
* 侵入式接口:在 PHP 这种单继承语言中，存在着严格的层级关系，一个类只能直接继承自一个父类，一个类也只能实现指定的接口，如果没有显式声明继承自某个父类或者实现某个接口，那么这个类就与该父类或者该接口没有任何关系
    - 实现类必须明确声明自己实现了某个接口。这种实现方式虽然足够明确和简单明了，但也存在一些问题，尤其是在设计标准库的时候，因为标准库必然涉及到接口设计，接口的需求方是业务实现类，只有具体编写业务实现类的时候才知道需要定义哪些方法，而在此之前，标准库的接口就已经设计好了，我们要么按照约定好的接口进行实现，如果没有合适的接口需要自己去设计，这里的问题就是接口的设计和业务的实现是分离的，接口的设计者并不能总是预判到业务方要实现哪些功能，这就造成了设计与实现的脱节
* 一个类只要实现了某个接口要求的所有方法，就说这个类实现了该接口

## 网络编程

* 从服务端来看，代码编写分为以下几个步骤：
    - 建立并绑定 Socket：首先服务端使用 socket() 函数建立网络套接字，然后使用 bind() 函数为套接字绑定指定的 IP 和端口；
    - 监听请求：接下来，服务端使用 listen() 函数监听客户端对绑定 IP 和端口的请求；
    - 接收连接：如果有请求过来，并通过三次握手成功建立连接，则使用 accept() 函数接收并处理该连接；
    - 处理请求与发送响应：服务端通过 read() 函数从上述已建立连接读取客户端发送的请求数据，经过处理后再通过 write() 函数将响应数据发送给客户端。
* 从客户端来看，代码编写分为以下几个步骤：
    - 建立 Socket：客户端同样使用 socket()函数建立网络套接字；
    - 建立连接：然后调用 connect() 函数传入 IP 和端口号建立与指定服务端网络程序的连接；
    - 发送请求与接收响应：连接建立成功后，客户端就可以通过 write() 函数向服务端发送数据，并使用 read() 函数从服务端接收响应。