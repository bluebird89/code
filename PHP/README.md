# 列表

* [Swoole 从入门到实战](https://xueyuanjun.com/books/swoole-tutorial)

## TDD

* 每步测试结果设想
* 测试就是需求
* 客户到底要的是什么，以什么优先级要
* 不要一下把复杂逻辑写出来,一步步来

* FizzBuzz
    * 打印出从1到100的数字，
    * 其中3的倍数替换成“Fizz”，
    * 5的倍数替换成“Buzz”，
    * 既能被3整除、又能被5整除的数则替换成“FizzBuzz”
    * 代码整洁，没有重复代码
    * 有单元测试，单元测试覆盖率100%
    * 10分钟内完成
* Args
    - Schema:数据类型验证,默认值
        + 默认值实现验证

## [设计模式](https://xueyuanjun.com/books/php-design-pattern)

* 创建型
    * 抽象工厂模式（Abstract Factory）
        - 抽象功能接口
        - 构建返回对象
    * 简单工厂模式（Simple Factory）
        - 实例化对象，而不需要客户了解这个对象属于哪个具体的子类
        - 用户根据参数获得对应的类实例，避免了直接实例化类
        - 需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用
    * 工厂方法模式（Factory Method）
        - 定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中
    * 静态工厂模式（Static Factory）
        - 与简单工厂类似，该模式用于创建一组相关或依赖的对象，不同之处在于静态工厂模式使用一个静态方法来创建所有类型的对象，该静态方法通常是 factory 或  build
    * 对象池模式（Object Pool）
        - 每次实例化的数量较少的情况下，使用对象池可以获得显著的性能提升
    * 原型模式（Prototype）
        - 创建原型使用克隆方法实现对象创建而不是使用标准的 new 方式
    * 单例模式（Singleton）
        - 保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点
    * 建造者模式（Builder）
        - 构建与表示分离
* 行为型
    - 责任链模式（Chain Of Responsibilities）
        + 将处理请求的对象连成一条链，沿着这条链传递该请求，直到有一个对象处理请求为止，这使得多个对象都有机会处理请求
        + 可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便
        + 缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便
    -  命令模式（Command）
        + 将请求封装成对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作
    - 迭代器模式（Iterator）
        + 提供一种方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节
    - 中介者模式（Mediator）
        + 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
        + 通过中介对象来封装对象之间的关系，使之各个对象在不需要知道其他对象的具体信息情况下通过中介者对象来与之通信。
        + 同时通过引用中介者对象来减少系统对象之间关系，提高了对象的可复用和系统的可扩展性。但是就是因为中介者对象封装了对象之间的关联关系，导致中介者对象变得比较庞大，所承担的责任也比较多。它需要知道每个对象和他们之间的交互细节，如果它出问题，将会导致整个系统都会出问题
    - 备忘录模式（Memento）
        + 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在合适的时候将该对象恢复到原先保存的状态
    - 空对象模式（Null Object）
        + 以前返回对象或 null 的方法现在返回对象或空对象 NullObject，这样会减少代码中的条件判断
    -  观察者模式（Observer）
        + 为对象实现发布/订阅功能：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作
    - 规格模式（Specification）
        + 组合模式的一种扩展。有时项目中某些条件决定了业务逻辑，这些条件就可以抽离出来以某种关系（与、或、非）进行组合，从而灵活地对业务逻辑进行定制
        + 在查询、过滤等应用场合中，通过预定义多个条件，然后使用这些条件的组合来处理查询或过滤，而不是使用逻辑判断语句来处理，可以简化整个实现逻辑。 
        + 这里的每个条件就是一个规格，多个规格/条件通过串联的方式以某种逻辑关系形成一个组合式的规格
    - 状态模式（State）
        + 当控制一个对象状态转换的条件表达式过于复杂时的情况。状态模式允许一个对象在其内部状态改变的时候改变其行为，把状态的判断逻辑转移到表示不同的一系列类当中，从而把复杂的逻辑判断简单化
        + 把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类
    - 策略模式（ Strategy）
    - 模板方法模式（Template Method）
        + 一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
    - 访问者模式（Visitor）
        + 一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作
* more
    - 服务定位器模式（Service Locator）:为应用程序中服务的创建和初始化提供一个中心位置
        + 服务定位器模式和依赖注入模式都是控制反转（IoC）模式的实现
        + 在服务定位器中注册给定接口的服务实例，然后通过接口获取服务并在应用代码中使用而不需要关心其具体实现
        + 在服务提供者中绑定接口及其实现，将服务实例注册到服务容器中，然后在使用时可以通过依赖注入或者通过服务接口/别名获取服务实例的方式调用服务
    - 委托模式（ Delegation）
        + 写一个附加的类提供附加的功能，并使用原来的类的实例提供原有的功能