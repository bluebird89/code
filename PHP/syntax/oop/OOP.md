# OOP

* 继承：子类可以通过继承的方式访问父类的属性和方法（protected 或者 public 方式定义）
    - 子类实例可以转化为父类
* 封装
    - 调用者无需关心对象方法实现细节
    - 通过访问控制限定属性和方法的可见性
* 多态:子类可以重写父类的同名方法，在子类对象中调用该方法会自动转发到子类方法调用
- 抽象类（Abstract Class）:包含抽象方法的类，而抽象方法是通过 abstract 关键字修饰的方法，抽象方法只是一个方法声明，不能有具体实现
- 接口:可以定义多个方法声明，方法声明不能有任何实现，并且这些方法的可见性都应该是 public，因为**接口中的方法都要被其他类实现**
    - 接口和抽象类一样不能被实例化只能被其他类实现
    + 和抽象类不同，接口中不包含任何具体的属性和方法，完全是待实现的「契约」，实现接口的类就相当于和它签了契约，必须要通过实现接口中声明的所有方法来履行契约
    + 通过接口类型定义方法中的参数类型约束，这样就可以传入实现该接口的对象实例进行实际的方法调用
    + 作为必须实现的契约保证：作为抽象类定义或者实现类的功能附加
* 只有接口和具体实现类两级结构，所有的实现类都要定义 某个属性，破坏了代码的复用性
    - 可以插入一个抽象类 BaseCar 作为中间层，来定义具体实现类的共有属性
    - 抽象类实现接口，接口方法声明为抽象方法就不需要在这一层实现，再让具体实现类继承抽象类并实现接口方法
    - 使用抽象类的好处是除了公共属性和方法这些可以被复用的代码外，对于接口中声明的方法可以直接通过抽象方法的方式抛给子类去实现，而不必在父类这一层级去实现
* 类型运算符 instanceof，用于判断某个对象实例是否实现了某个接口，或者是某个父类/抽象类的子类实例
* 对象组合水平扩展:在一个类中组合（或者说依赖）另一个类而不是继承另一个类来扩展功能
    * 契约声明，调用事项:考虑的是可以在对应方法中调用这个类型提供的某些方法，然后在调用该方法的地方传入的对象实例只要实现了这些方法即可，这样该方法就不会和具体的类绑定，提高了代码的扩展性和复用性
    × 定义方法参数时设定一个类型约束，然后调用该方法时，支持传入不同类的对象实例，并且需要通过某种机制保证这些类都实现了方法参数设定类型约束需要实现的方法，就好像它们之间达成了某种「契约」一样，不同的类都按照契约履行合同，而履行的方式就是实现类型约束要求提供的方法，传入的对象实例就可以正常在方法体中使用而不会出错
- 通过接口解除对具体类的依赖
    - 依赖注入：构造函数 普通方法
* trait:一种通过组合水平扩展类功能的机制
    - 支持属性和方法以及可见性设置（private、protected、public），并且即使是 private 级别的方法和属性，依然可以在使用类中调用
    - 把 Trait 的所有代码组合到使用类，变成了使用类的一部分。从另一个角度来印证，就是 Trait 中定义的属性不能再使用类中重复定义
    - 介于类继承和标准对象组合之间的一种存在，就像抽象类是不完全的面向接口编程一样
    - 多个 Trait 中包含同名方法:直接报冲突错误
        + 声明替换
        + 起别名
× 静态属性和静态方法：无需对类进行实例化，就可以直接调用这些属性和方法
    - 不能通过 $this 调用非静态属性/方法,通过 self:: 引用当前类的静态属性和方法
    - 支持动态修改
    - 一个类中调用其他类的静态属性和方法，需要通过 完整类名:: 进行引用
    - 静态方法的继承和重写
    - self 指向的是定义时持有它的类而不是调用时的
    - 后期静态绑定（Late Static Bindings）针对的是静态方法的调用，使用该特性时不再通过 self:: 引用静态方法，而是通过 static::. static 指向的是调用它的方法所在的类，而不是定义时
        - 如果是在定义它的类中调用，则指向当前类，和 self 功能一样
        - 如果是在子类或者其他类中调用，则指向调用该方法所在的类