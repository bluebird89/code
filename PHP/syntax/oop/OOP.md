# OOP

* 子类实例可以转化为父类，在声明这个类型约束时，更多考虑的是可以在对应方法中调用这个类型提供的某些方法，然后在调用该方法的地方传入的对象实例只要实现了这些方法即可，这样，该方法就不会和具体的类绑定，从而提高了代码的扩展性和复用性
定义方法参数时设定一个类型约束，然后调用该方法时，支持传入不同类的对象实例，并且需要通过某种机制保证这些类都实现了方法参数设定类型约束需要实现的方法，就好像它们之间达成了某种「契约」一样，不同的类都按照契约履行合同，而履行的方式就是实现类型约束要求提供的方法，这样一来，传入的对象实例就可以正常在方法体中使用而不会出错
    - 抽象类（Abstract Class）:包含抽象方法的类，而抽象方法是通过 abstract 关键字修饰的方法，抽象方法只是一个方法声明，不能有具体实现
    - 接口:可以定义多个方法声明，这些方法声明不能有任何实现，并且这些方法的可见性都应该是 public，因为接口中的方法都要被其他类实现
        - 接口和抽象类一样，也不能被实例化，只能被其他类实现
        + 和抽象类不同，接口中不包含任何具体的属性和方法，完全是待实现的「契约」，实现接口的类就相当于和它签了契约，必须要通过实现接口中声明的所有方法来履行契约
        + 通过接口类型定义方法中的参数类型约束，这样，就可以传入实现该接口的对象实例进行实际的方法调用
* 只有接口和具体实现类两级结构，所有的实现类都要定义 某个属性，破坏了代码的复用性
    - 可以插入一个抽象类 BaseCar 作为中间层，来定义具体实现类的共有属性
    - 抽象类实现接口，接口方法声明为抽象方法就不需要在这一层实现，再让具体实现类继承抽象类并实现接口方法
    - 使用抽象类的好处是除了公共属性和方法这些可以被复用的代码外，对于接口中声明的方法可以直接通过抽象方法的方式抛给子类去实现，而不必在父类这一层级去实现
* 类型运算符 instanceof，用于判断某个对象实例是否实现了某个接口，或者是某个父类/抽象类的子类实例
* 通过对象组合水平扩展 PHP 类功能:在一个类中组合（或者说依赖）另一个类而不是继承另一个类来扩展它的功能