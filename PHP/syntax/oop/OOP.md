# OOP

* 继承：子类可以通过继承的方式访问父类的属性和方法（protected 或者 public 方式定义）
    - 子类实例可以转化为父类
* 封装
    - 调用者无需关心对象方法实现细节
    - 通过访问控制限定属性和方法的可见性
* 多态:子类可以重写父类的同名方法，在子类对象中调用该方法会自动转发到子类方法调用
- 抽象类（Abstract Class）:包含抽象方法的类，而抽象方法是通过 abstract 关键字修饰的方法，抽象方法只是一个方法声明，不能有具体实现
- 接口:可以定义多个方法声明，方法声明不能有任何实现，并且这些方法的可见性都应该是 public，因为**接口中的方法都要被其他类实现**
    - 接口和抽象类一样不能被实例化只能被其他类实现
    + 和抽象类不同，接口中不包含任何具体的属性和方法，完全是待实现的「契约」，实现接口的类就相当于和它签了契约，必须要通过实现接口中声明的所有方法来履行契约
    + 通过接口类型定义方法中的参数类型约束，这样就可以传入实现该接口的对象实例进行实际的方法调用
    + 作为必须实现的契约保证：作为抽象类定义或者实现类的功能附加
* 只有接口和具体实现类两级结构，所有的实现类都要定义 某个属性，破坏了代码的复用性
    - 可以插入一个抽象类 BaseCar 作为中间层，来定义具体实现类的共有属性
    - 抽象类实现接口，接口方法声明为抽象方法就不需要在这一层实现，再让具体实现类继承抽象类并实现接口方法
    - 使用抽象类的好处是除了公共属性和方法这些可以被复用的代码外，对于接口中声明的方法可以直接通过抽象方法的方式抛给子类去实现，而不必在父类这一层级去实现
* 类型运算符 instanceof，用于判断某个对象实例是否实现了某个接口，或者是某个父类/抽象类的子类实例
* 对象组合水平扩展:在一个类中组合（或者说依赖）另一个类而不是继承另一个类来扩展功能
    * 契约声明，调用事项:考虑的是可以在对应方法中调用这个类型提供的某些方法，然后在调用该方法的地方传入的对象实例只要实现了这些方法即可，这样该方法就不会和具体的类绑定，提高了代码的扩展性和复用性
    × 定义方法参数时设定一个类型约束，然后调用该方法时，支持传入不同类的对象实例，并且需要通过某种机制保证这些类都实现了方法参数设定类型约束需要实现的方法，就好像它们之间达成了某种「契约」一样，不同的类都按照契约履行合同，而履行的方式就是实现类型约束要求提供的方法，传入的对象实例就可以正常在方法体中使用而不会出错
- 通过接口解除对具体类的依赖
    - 依赖注入：构造函数 普通方法
* trait:一种通过组合水平扩展类功能的机制
    - 支持属性和方法以及可见性设置（private、protected、public），并且即使是 private 级别的方法和属性，依然可以在使用类中调用
    - 把 Trait 的所有代码组合到使用类，变成了使用类的一部分。从另一个角度来印证，就是 Trait 中定义的属性不能再使用类中重复定义
    - 介于类继承和标准对象组合之间的一种存在，就像抽象类是不完全的面向接口编程一样
    - 多个 Trait 中包含同名方法:直接报冲突错误
        + 